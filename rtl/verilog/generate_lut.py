#!/usr/bin/env python3

"""
Lookup Table (LUT) Generator for Floating-Point Operations

This module generates Verilog RTL code for lookup tables used in floating-point
arithmetic operations, specifically for inverse square root and reciprocal
functions. It supports different floating-point precisions (fp16, fp32, fp64).

The module provides functionality to:
1. Generate inverse square root LUTs
2. Generate reciprocal LUTs
3. Splice generated LUT modules into existing Verilog files

Usage:
    python generate_lut.py --type <recip|invsqrt> --precision <fp16|fp32|fp64> 
                           [--output <output_file>] [--splice <target_file>]

Functions:
    generate_invsqrt_lut(precision_str): Generates Verilog RTL for inverse square root LUT
    generate_recip_lut(precision_str): Generates Verilog RTL for reciprocal LUT
    splice_module_into_file(target_filepath, module_name, new_module_code): 
        Replaces an existing module in a Verilog file with a new one
    main(): Parses command-line arguments and orchestrates LUT generation

This script is part of a larger hardware description language (HDL) library
for implementing floating-point arithmetic operations in digital circuits.
"""

import argparse
import math
import os
import re
import textwrap
from typing import Tuple

# Define the warning comment block to be used in all generated files/modules.
GENERATED_MODULE_WARNING = textwrap.dedent("""\
//======================================================================
//
// WARNING: THIS MODULE IS AUTO-GENERATED BY generate_lut.py.
//          DO NOT EDIT THIS MODULE MANUALLY.
//          MANUAL EDITS WILL BE OVERWRITTEN ON THE NEXT SCRIPT RUN.
//
//======================================================================
""")

def generate_invsqrt_lut(precision: str) -> Tuple[str, str, str]:
    """Generates the Verilog RTL for an inverse square root LUT."""

    if precision == 'fp16':
        module_name = "invsqrt_lut_16b"
        addr_width = 5
        mant_addr_bits = 4
        data_width = 13
        internal_precision = 12
    elif precision == 'fp32':
        module_name = "invsqrt_lut_32b"
        addr_width = 8
        mant_addr_bits = 7
        data_width = 26
        internal_precision = 25
    elif precision == 'fp64':
        module_name = "invsqrt_lut_64b"
        addr_width = 10
        mant_addr_bits = 9
        data_width = 55
        internal_precision = 54
    else:
        raise ValueError(f"Invalid precision string {precision}.")

    num_entries = 2**addr_width
    addr_hex_width = (addr_width + 3) // 4
    data_hex_width = (data_width + 3) // 4

    verilog_code = GENERATED_MODULE_WARNING + textwrap.dedent(f"""\
    // Verilog RTL Generated by generate_lut.py
    // LUT for {precision} inverse square root initial guess.
    // Function: 1/sqrt(M)
    // M is constructed from the exponent LSB and mantissa MSBs.

    module {module_name} (
        input  [{addr_width-1}:0] addr,
        output reg [{data_width-1}:0] data
    );

        // This is a large ({num_entries}-entry) but synthesizable LUT.
        // It will typically be implemented as a ROM in an FPGA or ASIC.
        always @(*) begin
            case (addr)
    """)

    for i in range(num_entries):
        exp_lsb = i >> mant_addr_bits
        mant_msbs = i & ((1 << mant_addr_bits) - 1)

        # Reconstruct the value M that the address represents.
        # M is in the range [1.0, 4.0)
        m_mant = 1.0 + (mant_msbs / float(1 << mant_addr_bits))
        m_val = m_mant * (2.0 ** exp_lsb)

        # Calculate the ideal result
        invsqrt_m = 1.0 / math.sqrt(m_val)

        # Convert to fixed-point format 1.P
        data_val = int(invsqrt_m * (2**internal_precision))

        verilog_code += f"                {addr_width}'h{i:0{addr_hex_width}x}: data = {data_width}'h{data_val:0{data_hex_width}x};\n"

    verilog_code += textwrap.dedent(f"""\
                default: data = {data_width}'h{int(1.0 * (2**internal_precision)):0{data_hex_width}x}; // Should not be reached
            endcase
        end

    endmodule
    """)

    return verilog_code, module_name, f"{module_name}.v"

def generate_recip_lut(precision: str) -> Tuple[str, str, str]:
    """Generates the Verilog RTL for a reciprocal LUT."""

    if precision == 'fp16':
        module_name = "reciprocal_lut_16b"
        addr_width = 4
        data_width = 13
        internal_precision = 12
    elif precision == 'fp32':
        module_name = "reciprocal_lut_32b"
        addr_width = 8
        data_width = 26
        internal_precision = 25
    elif precision == 'fp64':
        module_name = "reciprocal_lut_64b"
        addr_width = 10
        data_width = 55
        internal_precision = 54
    else:
        raise ValueError(f"Invalid precision string {precision}.")

    num_entries = 2**addr_width
    addr_hex_width = (addr_width + 3) // 4
    data_hex_width = (data_width + 3) // 4

    verilog_code = GENERATED_MODULE_WARNING + textwrap.dedent(f"""\
    // Verilog RTL Generated by generate_lut.py
    // LUT for {precision} reciprocal initial guess.
    // Function: 1/M
    // M is constructed from the mantissa MSBs.

    module {module_name} (
        input  [{addr_width-1}:0] addr,
        output reg [{data_width-1}:0] data
    );

        always @(*) begin
            case (addr)
    """)

    for i in range(num_entries):
        # Reconstruct the value M (1.mant)
        m_val = 1.0 + (i / float(1 << addr_width))

        # Calculate the ideal result
        recip_m = 1.0 / m_val

        # Convert to fixed-point format 1.P or 0.P
        data_val = int(recip_m * (2**internal_precision))

        verilog_code += f"                {addr_width}'h{i:0{addr_hex_width}x}: data = {data_width}'h{data_val:0{data_hex_width}x};\n"

    verilog_code += textwrap.dedent(f"""\
                default: data = {data_width}'h{int(1.0 * (2**internal_precision)):0{data_hex_width}x};
            endcase
        end

    endmodule
    """)

    return verilog_code, module_name, f"{module_name}.v"

def splice_module_into_file(target_filepath: str, module_name: str, new_module_code: str) -> None:
    """Finds a Verilog module by name in a target file and replaces it."""
    if not os.path.exists(target_filepath):
        print(f"Error: Splice target file '{target_filepath}' not found.")
        return

    try:
        with open(target_filepath, 'r', encoding='utf-8') as f:
            original_content = f.read()

        # Regex to find the whole module definition, from 'module' to 'endmodule'.
        # This handles various code styles and comments.
        pattern = re.compile(
            r"^\s*module\s+" + re.escape(module_name) + r"\s*.*?^\s*endmodule",
            re.DOTALL | re.MULTILINE
        )

        if not pattern.search(original_content):
            print(f"Error: Module '{module_name}' not found in '{target_filepath}'. No changes were made.")
            return

        # Replace the found module with the new code
        updated_content = pattern.sub(new_module_code.strip(), original_content)

        with open(target_filepath, 'w', encoding='utf-8') as f:
            f.write(updated_content)

        print(f"Successfully spliced module '{module_name}' into '{target_filepath}'.")

    except Exception as e:
        print(f"An error occurred during the splice operation: {e}")

def run_generation(func_type: str, precision: str, splice: bool, output_file: str | None) -> None:
    """Handles the core logic for generating or splicing a single LUT."""
    if func_type == 'invsqrt':
        verilog_code, module_name, filename = generate_invsqrt_lut(precision)
    elif func_type == 'recip':
        verilog_code, module_name, filename = generate_recip_lut(precision)
    else:
        # This case should not be reachable due to 'choices' in argparser
        raise ValueError(f"Invalid function type specified: {func_type}")

    if splice:
        # Construct the target filename based on type and precision
        base_filename = f"{precision}_{func_type}.v"

        # Assumes the script is run from rtl/verilog/
        target_filepath = os.path.join(precision, base_filename)

        splice_module_into_file(target_filepath, module_name, verilog_code)
    else:
        # Determine output directory based on precision
        output_dir = precision
        os.makedirs(output_dir, exist_ok=True)

        # Use user-specified filename or the default
        output_path = output_file if output_file else os.path.join(output_dir, filename)

        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(verilog_code)
        print(f"Successfully generated '{output_path}'")

def parse_args() -> Tuple[argparse.ArgumentParser, argparse.Namespace]:
    """Parses and returns the command-line arguments."""
    parser = argparse.ArgumentParser(
        description="Generate Verilog RTL for a floating-point function lookup table (LUT).",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        'command',
        type=str,
        nargs='?',
        choices=['all'],
        help="Optional supercommand. Use 'all' to generate LUTs for all types and precisions."
    )
    parser.add_argument(
        '--type',
        type=str,
        choices=['recip', 'invsqrt'],
        help="The type of function for the LUT. Required if 'all' is not used."
    )
    parser.add_argument(
        '--precision',
        type=str,
        choices=['fp16', 'fp32', 'fp64'],
        help="The floating-point precision. Required if 'all' is not used."
    )
    parser.add_argument(
        '-o', '--output',
        type=str,
        help="Optional: Output file name. Overrides default naming and path. Ignored if 'all' is used."
    )
    parser.add_argument(
        '--splice',
        action='store_true',
        help="Splice the generated LUT into the corresponding function's Verilog file (e.g., fp32/fp32_invsqrt.v)."
    )
    return parser, parser.parse_args()

def main() -> None:
    """Main function to parse arguments and generate the LUT."""
    parser, args = parse_args()

    try:
        if args.command == 'all':
            action = "Splicing" if args.splice else "Generating"
            print(f"Running 'all' command: {action} all LUTs.")
            types = ['recip', 'invsqrt']
            precisions = ['fp16', 'fp32', 'fp64']
            for p in precisions:
                for t in types:
                    print(f"--- Processing {p} {t} ---")
                    run_generation(func_type=t, precision=p, splice=args.splice, output_file=None)
            print("--- 'all' command complete. ---")
        else:
            if not args.type or not args.precision:
                parser.error("--type and --precision are required when not using the 'all' command.")
            run_generation(func_type=args.type, precision=args.precision, splice=args.splice, output_file=args.output)

    except ValueError as e:
        print(f"Error: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

if __name__ == '__main__':
    main()
